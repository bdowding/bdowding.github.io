<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Piano Keyboard Delay Scatter</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
    </style>
</head>
<body>
    <h1>Piano Keyboard Delay Scatter</h1>
    <div>
        <button id="midi-btn">Connect MIDI</button>
        <span id="midi-status">MIDI not connected</span>
    </div>
    <div style="margin-top:40px">
        <canvas id="scatter" width="600" height="150"></canvas>
    </div>
    <div style="margin-top:40px">
        <canvas id="scatterLeft" width="600" height="150"></canvas>
    </div>
    <div id="keyboard" style="display:none">
        <div class="key" data-note="C3">Z</div>
        <div class="key" data-note="D3">X</div>
        <div class="key" data-note="E3">C</div>
        <div class="key" data-note="F3">V</div>
        <div class="key" data-note="G3">B</div>
        <div class="key" data-note="A3">N</div>
        <div class="key" data-note="B3">M</div>
        <div class="key" data-note="C4">A</div>
        <div class="key" data-note="D4">S</div>
        <div class="key" data-note="E4">D</div>
        <div class="key" data-note="F4">F</div>
        <div class="key" data-note="G4">G</div>
        <div class="key" data-note="A4">H</div>
        <div class="key" data-note="B4">J</div>
        <div class="key" data-note="C5">K</div>
    </div>
    <script>
        let noteTimes = [];
        let noteKeys = [];
        let scatterChart = null;
        let scatterChartLeft = null;
        // Reset every 10 seconds
        setInterval(() => { noteTimes = []; noteKeys = []; drawScatter(); }, 10000);
        // MIDI setup
        let midiAccess = null;
        document.getElementById('midi-btn').onclick = async function() {
            if (navigator.requestMIDIAccess) {
                midiAccess = await navigator.requestMIDIAccess();
                document.getElementById('midi-status').textContent = 'MIDI connected';
                for (let input of midiAccess.inputs.values()) {
                    input.onmidimessage = function(msg) {
                        const [cmd, noteNum, velocity] = msg.data;
                        if (cmd === 144 && velocity > 0) {
                            // Only support keyboard for hand logic for now
                            // Could add MIDI mapping if needed
                            noteTimes.push(Date.now());
                            noteKeys.push(null); // MIDI notes not mapped
                            drawScatter();
                        }
                    };
                }
            } else {
                document.getElementById('midi-status').textContent = 'Web MIDI API not supported';
            }
        };
        const keyMap = {
            'Z': 'C3', 'X': 'D3', 'C': 'E3', 'V': 'F3', 'B': 'G3', 'N': 'A3', 'M': 'B3',
            'A': 'C4', 'S': 'D4', 'D': 'E4', 'F': 'F4', 'G': 'G4', 'H': 'A4', 'J': 'B4', 'K': 'C5'
        };
        // MIDI note numbers for C3=48, C#3=49, D3=50, ..., C4=60, ..., C5=72
        function noteToMidi(note) {
            const noteNames = { 'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'A#':10, 'B':11 };
            let match = note.match(/^([A-G]#?)([0-9])$/);
            if (!match) return null;
            let name = match[1];
            let octave = parseInt(match[2]);
            return 12 * octave + noteNames[name];
        }
        function halfStepDistance(note1, note2) {
            let midi1 = noteToMidi(note1);
            let midi2 = noteToMidi(note2);
            if (midi1 === null || midi2 === null) return null;
            return Math.abs(midi2 - midi1);
        }
        function assignHands(keys) {
            if (keys.length === 0) return [];
            let hands = [];
            let rightHand = [keys[0]];
            let leftHand = [];
            hands.push('right');
            for (let i = 1; i < keys.length; i++) {
                let note = keys[i];
                if (!note) { hands.push('unknown'); continue; }
                // If left hand is empty, use right hand rules
                if (leftHand.length === 0) {
                    let prevNote = rightHand[rightHand.length-1];
                    let dist = halfStepDistance(prevNote, note);
                    if (dist !== null && dist <= 10) { // 5 steps = 10 half-steps
                        hands.push('right');
                        rightHand.push(note);
                    } else {
                        hands.push('left');
                        leftHand.push(note);
                    }
                } else {
                    // Compare to most recent note of each hand
                    let prevRight = rightHand[rightHand.length-1];
                    let prevLeft = leftHand[leftHand.length-1];
                    let distRight = halfStepDistance(prevRight, note);
                    let distLeft = halfStepDistance(prevLeft, note);
                    if (distRight <= distLeft) {
                        hands.push('right');
                        rightHand.push(note);
                    } else {
                        hands.push('left');
                        leftHand.push(note);
                    }
                }
            }
            return hands;
        }
        document.addEventListener('keydown', e => {
            const note = keyMap[e.key.toUpperCase()];
            if (note) {
                noteTimes.push(Date.now());
                noteKeys.push(note);
                drawScatter();
            }
        });
        document.addEventListener('keyup', e => {
            // No UI to update, but could be used for future features
        });
        function assignHands(keys) {
            // Implements the hand assignment rules
            if (keys.length === 0) return [];
            let hands = [];
            let rightHand = [keys[0]];
            let leftHand = [];
            hands.push('right');
            for (let i = 1; i < keys.length; i++) {
                let note = keys[i];
                if (!note) { hands.push('unknown'); continue; }
                // If left hand is empty, use right hand rules
                if (leftHand.length === 0) {
                    let prevNote = rightHand[rightHand.length-1];
                    let dist = halfStepDistance(prevNote, note);
                    if (dist !== null && dist <= 10) { // 5 steps = 10 half-steps
                        hands.push('right');
                        rightHand.push(note);
                    } else {
                        hands.push('left');
                        leftHand.push(note);
                    }
                } else {
                    // Compare to most recent note of each hand
                    let prevRight = rightHand[rightHand.length-1];
                    let prevLeft = leftHand[leftHand.length-1];
                    let distRight = halfStepDistance(prevRight, note);
                    let distLeft = halfStepDistance(prevLeft, note);
                    if (distRight <= distLeft) {
                        hands.push('right');
                        rightHand.push(note);
                    } else {
                        hands.push('left');
                        leftHand.push(note);
                    }
                }
            }
            return hands;
        }
        function drawScatter() {
            // Calculate delays and assign hands
            let dataRight = [];
            let dataLeft = [];
            let maxDelayR = 1000;
            let maxDelayL = 1000;
            let hands = assignHands(noteKeys);
            for (let i = 1; i < noteTimes.length; i++) {
                let delay = noteTimes[i] - noteTimes[i-1];
                if (hands[i] === 'right') {
                    dataRight.push({x: noteTimes[i] - noteTimes[0], y: delay});
                    if (delay > maxDelayR) maxDelayR = Math.ceil(delay / 1000) * 1000;
                } else if (hands[i] === 'left') {
                    dataLeft.push({x: noteTimes[i] - noteTimes[0], y: delay});
                    if (delay > maxDelayL) maxDelayL = Math.ceil(delay / 1000) * 1000;
                }
            }
            // Right hand chart
            const ctx = document.getElementById('scatter').getContext('2d');
            if (scatterChart) scatterChart.destroy();
            scatterChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Right Hand Delay (ms)',
                        data: dataRight,
                        backgroundColor: 'rgba(0,123,255,0.7)',
                    }]
                },
                options: {
                    animation: false,
                    plugins: { title: { display: false } },
                    scales: {
                        x: {
                            min: 0,
                            max: 10000
                        },
                        y: {
                            min: 0,
                            max: maxDelayR
                        }
                    }
                }
            });
            // Left hand chart
            const ctxL = document.getElementById('scatterLeft').getContext('2d');
            if (scatterChartLeft) scatterChartLeft.destroy();
            scatterChartLeft = new Chart(ctxL, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Left Hand Delay (ms)',
                        data: dataLeft,
                        backgroundColor: 'rgba(255,123,0,0.7)',
                    }]
                },
                options: {
                    animation: false,
                    plugins: { title: { display: false } },
                    scales: {
                        x: {
                            min: 0,
                            max: 10000
                        },
                        y: {
                            min: 0,
                            max: maxDelayL
                        }
                    }
                }
            });
        }
        drawScatter();
    </script>
</body>
</html>
