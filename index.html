<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Piano Keyboard Delay Scatter</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
        }
        .header {
            height: 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 10px;
        }
        .chart-section {
            height: calc((100vh - 40px) / 2);
            margin-bottom: 5px;
        }
        .chart-section canvas {
            width: 100% !important;
            height: 100% !important;
        }
    </style>
</head>
<body>
    <div class="header">
        <span id="midi-status">Connecting to MIDI...</span>
    </div>
    <div class="chart-section">
        <canvas id="scatter"></canvas>
    </div>
    <div class="chart-section">
        <canvas id="scatterLeft"></canvas>
    </div>
    <div id="keyboard" style="display:none">
        <div class="key" data-note="C3">Z</div>
        <div class="key" data-note="D3">X</div>
        <div class="key" data-note="E3">C</div>
        <div class="key" data-note="F3">V</div>
        <div class="key" data-note="G3">B</div>
        <div class="key" data-note="A3">N</div>
        <div class="key" data-note="B3">M</div>
        <div class="key" data-note="C4">A</div>
        <div class="key" data-note="D4">S</div>
        <div class="key" data-note="E4">D</div>
        <div class="key" data-note="F4">F</div>
        <div class="key" data-note="G4">G</div>
        <div class="key" data-note="A4">H</div>
        <div class="key" data-note="B4">J</div>
        <div class="key" data-note="C5">K</div>
    </div>
    <script>
        // Hand class to represent one hand's data
        class Hand {
            constructor(name) {
                this.name = name;
                this.notes = [];        // MIDI note numbers
                this.times = [];        // Timestamps
                this.velocities = [];   // Velocity values
                this.delayData = [];    // Calculated delay data points
                this.velocityData = []; // Calculated velocity data points
                this.delayFit = null;   // Line of best fit for delays
                this.velocityFit = null; // Line of best fit for velocities
            }
            
            addNote(midiNote, time, velocity) {
                this.notes.push(midiNote);
                this.times.push(time);
                this.velocities.push(velocity);
            }
            
            clear() {
                this.notes = [];
                this.times = [];
                this.velocities = [];
                this.delayData = [];
                this.velocityData = [];
                this.delayFit = null;
                this.velocityFit = null;
            }
            
            getLastNote() {
                return this.notes.length > 0 ? this.notes[this.notes.length - 1] : null;
            }
            
            getRange() {
                if (this.notes.length === 0) return { min: null, max: null };
                return {
                    min: Math.min(...this.notes),
                    max: Math.max(...this.notes)
                };
            }
            
            distanceTo(midiNote) {
                if (this.notes.length === 0) return Infinity;
                const range = this.getRange();
                return Math.min(
                    Math.abs(midiNote - range.min),
                    Math.abs(midiNote - range.max)
                );
            }
        }
        
        // Create two hand instances
        let rightHand = new Hand('right');
        let leftHand = new Hand('left');
        
        let scatterChart = null;
        let scatterChartLeft = null;
        let lastInputTime = null;
        let scoreTimeout = null;
        
        function calculateLineOfBestFit(data, forceZeroGradient = false) {
            if (data.length < 2) return null;
            let n = data.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
            
            for (let point of data) {
                sumX += point.x;
                sumY += point.y;
                sumXY += point.x * point.y;
                sumXX += point.x * point.x;
            }
            
            let slope, intercept;
            if (forceZeroGradient) {
                slope = 0;
                intercept = sumY / n; // Mean Y value
            } else {
                slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
                intercept = (sumY - slope * sumX) / n;
            }
            
            // Calculate R-squared
            let meanY = sumY / n;
            let ssTotal = 0, ssRes = 0;
            for (let point of data) {
                let predicted = slope * point.x + intercept;
                ssTotal += Math.pow(point.y - meanY, 2);  // Total sum of squares
                ssRes += Math.pow(point.y - predicted, 2); // Residual sum of squares
            }
            
            // R² = 1 - (SS_res / SS_tot)
            // Handle edge cases:
            // - If ssTotal = 0 (all y values are the same), R² should be 1 if fit is perfect, NaN otherwise
            // - If ssRes = 0 (perfect fit), R² = 1
            // - R² can be negative if the fit is worse than just using the mean
            
            let rSquared;
            if (ssTotal === 0) {
                // All y values are identical
                rSquared = (ssRes === 0) ? 1 : 0; // Perfect if no residuals, otherwise 0
            } else {
                rSquared = 1 - (ssRes / ssTotal);
                // R² can be negative if the model is worse than the mean
                // We'll keep negative values for diagnostic purposes but clamp in scoring
            }
            
            return { slope, intercept, rSquared };
        }
        
        function createLineData(fit, minX, maxX) {
            if (!fit) return [];
            return [
                { x: minX, y: fit.slope * minX + fit.intercept },
                { x: maxX, y: fit.slope * maxX + fit.intercept }
            ];
        }
        
        function showScore() {
            // Calculate delay data from Hand objects
            let dataRightDelay = [];
            let dataLeftDelay = [];
            let dataRightVelocity = [];
            let dataLeftVelocity = [];
            let lastTimeRight = null;
            let lastTimeLeft = null;
            
            // Calculate common start time
            let startTime = 0;
            if (rightHand.times.length > 0 && leftHand.times.length > 0) {
                startTime = Math.min(rightHand.times[0], leftHand.times[0]);
            } else if (rightHand.times.length > 0) {
                startTime = rightHand.times[0];
            } else if (leftHand.times.length > 0) {
                startTime = leftHand.times[0];
            }
            
            // Process right hand data
            for (let i = 0; i < rightHand.times.length; i++) {
                let time = rightHand.times[i];
                let velocity = rightHand.velocities[i];
                
                if (lastTimeRight !== null) {
                    let delay = time - lastTimeRight;
                    dataRightDelay.push({x: time - startTime, y: delay});
                }
                dataRightVelocity.push({x: time - startTime, y: velocity});
                lastTimeRight = time;
            }
            
            // Process left hand data
            for (let i = 0; i < leftHand.times.length; i++) {
                let time = leftHand.times[i];
                let velocity = leftHand.velocities[i];
                
                if (lastTimeLeft !== null) {
                    let delay = time - lastTimeLeft;
                    dataLeftDelay.push({x: time - startTime, y: delay});
                }
                dataLeftVelocity.push({x: time - startTime, y: velocity});
                lastTimeLeft = time;
            }
            
            // Calculate fits and store in Hand objects
            rightHand.delayFit = calculateLineOfBestFit(dataRightDelay, true);
            leftHand.delayFit = calculateLineOfBestFit(dataLeftDelay, true);
            rightHand.velocityFit = calculateLineOfBestFit(dataRightVelocity, false);
            leftHand.velocityFit = calculateLineOfBestFit(dataLeftVelocity, false);
            
            // Debug logging
            console.log('Left hand delay data:', dataLeftDelay);
            console.log('Left hand delay fit:', leftHand.delayFit);
            console.log('Left hand velocity data:', dataLeftVelocity);
            console.log('Left hand velocity fit:', leftHand.velocityFit);
            
            // Store fits globally for chart rendering (for backward compatibility)
            window.chartFits = {
                rightDelayFit: rightHand.delayFit,
                leftDelayFit: leftHand.delayFit,
                rightVelocityFit: rightHand.velocityFit,
                leftVelocityFit: leftHand.velocityFit
            };
            
            // Redraw charts with fit lines
            drawScatter();
        }
        
        function handleNoteInput(note, velocity = 1 + Math.random() * 0.3) {
            const now = Date.now();
            if (lastInputTime && now - lastInputTime > 2000) {
                rightHand.clear();
                leftHand.clear();
                window.chartFits = null;
            }
            
            if (scoreTimeout) clearTimeout(scoreTimeout);
            scoreTimeout = setTimeout(showScore, 2000);
            
            lastInputTime = now;
            let midiNote = typeof note === 'string' ? noteToMidi(note) : note;
            
            // Add note to appropriate hand based on current assignment logic
            assignHands(midiNote, now, velocity);
            drawScatter();
        }
        // MIDI setup - Auto-connect on page load
        let midiAccess = null;
        
        async function connectMIDI() {
            if (navigator.requestMIDIAccess) {
                try {
                    midiAccess = await navigator.requestMIDIAccess();
                    document.getElementById('midi-status').textContent = 'MIDI connected';
                    for (let input of midiAccess.inputs.values()) {
                        input.onmidimessage = function(msg) {
                            const [cmd, noteNum, velocity] = msg.data;
                            if (cmd === 144 && velocity > 0) {
                                handleNoteInput(noteNum, velocity / 127); // Pass MIDI number directly
                            }
                        };
                    }
                } catch (error) {
                    document.getElementById('midi-status').textContent = 'MIDI connection failed';
                }
            } else {
                document.getElementById('midi-status').textContent = 'Web MIDI API not supported';
            }
        }
        
        // Auto-connect when page loads
        window.addEventListener('load', connectMIDI);
        const keyMap = {
            'Z': 'C3', 'X': 'D3', 'C': 'E3', 'V': 'F3', 'B': 'G3', 'N': 'A3', 'M': 'B3',
            'A': 'C4', 'S': 'D4', 'D': 'E4', 'F': 'F4', 'G': 'G4', 'H': 'A4', 'J': 'B4', 'K': 'C5'
        };
        // MIDI note numbers for C3=48, C#3=49, D3=50, ..., C4=60, ..., C5=72
        function noteToMidi(note) {
            const noteNames = { 'C':0, 'C#':1, 'D':2, 'D#':3, 'E':4, 'F':5, 'F#':6, 'G':7, 'G#':8, 'A':9, 'A#':10, 'B':11 };
            let match = note.match(/^([A-G]#?)([0-9])$/);
            if (!match) return null;
            let name = match[1];
            let octave = parseInt(match[2]);
            return 12 * octave + noteNames[name];
        }
        
        function midiToNote(midiNum) {
            const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
            let octave = Math.floor(midiNum / 12) - 1;
            let name = noteNames[midiNum % 12];
            return name + octave;
        }
        
        function halfStepDistance(midi1, midi2) {
            if (midi1 === null || midi2 === null) return null;
            return Math.abs(midi2 - midi1);
        }
        function assignHands(midiNote, time, velocity) {
            // If this is the first note, assign to right hand
            if (rightHand.notes.length === 0 && leftHand.notes.length === 0) {
                rightHand.addNote(midiNote, time, velocity);
                return 'right';
            }
            
            // If left hand is still empty, check if this note creates the split
            if (leftHand.notes.length === 0) {
                let lastRightNote = rightHand.getLastNote();
                let distance = halfStepDistance(lastRightNote, midiNote);
                
                if (distance !== null && distance > 5) {
                    // This is the split point - assign this note to left hand
                    leftHand.addNote(midiNote, time, velocity);
                    return 'left';
                } else {
                    // Still within 5 steps, stays with right hand
                    rightHand.addNote(midiNote, time, velocity);
                    return 'right';
                }
            } else {
                // Both hands are now active - compare to most recent note from each hand
                let lastRightNote = rightHand.getLastNote();
                let lastLeftNote = leftHand.getLastNote();
                
                let distToRight = halfStepDistance(lastRightNote, midiNote);
                let distToLeft = halfStepDistance(lastLeftNote, midiNote);
                
                if (distToRight <= distToLeft) {
                    rightHand.addNote(midiNote, time, velocity);
                    return 'right';
                } else {
                    leftHand.addNote(midiNote, time, velocity);
                    return 'left';
                }
            }
        }
        document.addEventListener('keydown', e => {
            const note = keyMap[e.key.toUpperCase()];
            if (note) {
                handleNoteInput(note);
            }
        });
        document.addEventListener('keyup', e => {
            // No UI to update, but could be used for future features
        });
        function calculateScore(fit, dataPoints) {
            // Calculate score using Root Mean Squared Error (RMSE) for both timing and velocity
            
            if (!fit || !dataPoints || dataPoints.length < 2) {
                return 10; // Minimum score for insufficient data
            }
            
            // Calculate RMSE between actual points and fit line
            let sumSquaredErrors = 0;
            for (let point of dataPoints) {
                const predicted = fit.slope * point.x + fit.intercept;
                const error = point.y - predicted;
                sumSquaredErrors += error * error;
            }
            const rmse = Math.sqrt(sumSquaredErrors / dataPoints.length);
            
            // Determine if this is timing data or velocity data for appropriate scaling
            const yValues = dataPoints.map(p => p.y);
            const meanY = yValues.reduce((a, b) => a + b, 0) / yValues.length;
            const isVelocityData = meanY >= 0 && meanY <= 1.5;
            
            // Convert RMSE to score (lower RMSE = higher score)
            let score;
            if (isVelocityData) {
                // VELOCITY: RMSE typically 0-0.5, scale accordingly
                // RMSE = 0.0 → 100%, RMSE = 0.1 → ~60%, RMSE = 0.2 → ~25%
                score = 100 * Math.exp(-10 * rmse);
            } else {
                // TIMING: RMSE typically 0-200ms, scale accordingly  
                // RMSE = 0ms → 100%, RMSE = 50ms → ~60%, RMSE = 100ms → ~25%
                score = 100 * Math.exp(-0.02 * rmse);
            }
            
            // Apply minimum floor and maximum ceiling
            return Math.max(10, Math.min(100, score));
        }
        
        function createChart(canvasId, hand, datasets, maxDelay, maxTime, fits) {
            const ctx = document.getElementById(canvasId).getContext('2d');
            const chartVar = hand === 'right' ? 'scatterChart' : 'scatterChartLeft';
            
            // Destroy existing chart
            if (window[chartVar]) window[chartVar].destroy();
            
            // Add fit lines if available
            if (fits) {
                const delayFit = hand === 'right' ? fits.rightDelayFit : fits.leftDelayFit;
                const velocityFit = hand === 'right' ? fits.rightVelocityFit : fits.leftVelocityFit;
                const delayColor = 'rgba(255,0,0,1)'; // Red for timing
                const velocityColor = 'rgba(0,255,0,1)'; // Green for velocity
                
                if (delayFit && datasets[0].data.length > 0) {
                    datasets.push({
                        label: 'Timing Fit (0% gradient)',
                        data: createLineData(delayFit, 0, maxTime),
                        borderColor: delayColor,
                        backgroundColor: 'transparent',
                        type: 'line',
                        pointRadius: 0,
                        borderWidth: 2,
                        yAxisID: 'y',
                        showLine: true,
                        fill: false,
                        pointHoverRadius: 0,
                        pointHitRadius: 0,
                        hidden: false,
                        skipLegend: true
                    });
                }
                
                if (velocityFit && datasets[1].data.length > 0) {
                    let gradientPerNote = velocityFit.slope * 1000;
                    datasets.push({
                        label: `Velocity Fit (${(gradientPerNote * 100).toFixed(2)}% per note)`,
                        data: createLineData(velocityFit, 0, maxTime),
                        borderColor: velocityColor,
                        backgroundColor: 'transparent',
                        type: 'line',
                        pointRadius: 0,
                        borderWidth: 2,
                        yAxisID: 'y1',
                        showLine: true,
                        fill: false,
                        pointHoverRadius: 0,
                        pointHitRadius: 0,
                        hidden: false,
                        skipLegend: true
                    });
                }
            }
            
            // Create chart
            window[chartVar] = new Chart(ctx, {
                type: 'scatter',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        title: { display: false },
                        legend: {
                            labels: {
                                filter: function(legendItem, chartData) {
                                    const dataset = chartData.datasets[legendItem.datasetIndex];
                                    return !dataset.skipLegend;
                                }
                            }
                        },
                        datalabels: {
                            align: 'top',
                            font: { weight: 'bold' },
                            formatter: function(value, context) { 
                                return context.datasetIndex === 0 ? value.note : '';
                            }
                        }
                    },
                    scales: {
                        x: { min: 0, max: Math.max(10000, maxTime + 1000) },
                        y: { 
                            type: 'linear',
                            display: true,
                            position: 'left',
                            min: 0, 
                            max: maxDelay,
                            title: { display: true, text: 'Delay (ms)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            min: 0,
                            max: 1.5,
                            title: { display: true, text: 'Velocity' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
            
            // Add score boxes
            const timingScore = fits && fits[hand + 'DelayFit'] && datasets[0].data.length > 0 ? 
                calculateScore(fits[hand + 'DelayFit'], datasets[0].data) : 0;
            const velocityScore = fits && fits[hand + 'VelocityFit'] && datasets[1].data.length > 0 ? 
                calculateScore(fits[hand + 'VelocityFit'], datasets[1].data) : 0;
            const scoreText = timingScore != null && velocityScore != null ? 
                `Timing:${timingScore.toFixed(1)}% \nPressure:${velocityScore.toFixed(1)}%` : '';
            
            if (scoreText && fits) {
                setTimeout(() => {
                    const canvas = document.getElementById(canvasId);
                    const rect = canvas.getBoundingClientRect();
                    const className = `score-box-${hand}`;
                    
                    // Remove existing score boxes for this chart
                    document.querySelectorAll(`.${className}`).forEach(el => el.remove());
                    
                    const delayFit = fits[hand + 'DelayFit'];
                    const velocityFit = fits[hand + 'VelocityFit'];
                    const delayBgColor = hand === 'right' ? 'rgba(0,123,255,0.9)' : 'rgba(255,123,0,0.9)';
                    const velocityBgColor = hand === 'right' ? 'rgba(0,255,123,0.9)' : 'rgba(255,0,123,0.9)';
                    
                    // Calculate chart area bounds (excluding axis labels)
                    const chartAreaLeft = rect.left + 60; // Account for left axis
                    const chartAreaRight = rect.right - 60; // Account for right axis
                    const chartAreaWidth = chartAreaRight - chartAreaLeft;
                    const chartAreaTop = rect.top + 20; // Account for top padding
                    const chartAreaBottom = rect.bottom - 40; // Account for bottom axis
                    const chartAreaHeight = chartAreaBottom - chartAreaTop;
                    
                    // Create single centered score box with both timing and velocity scores
                    if ((delayFit && datasets[0].data.length > 0) || (velocityFit && datasets[1].data.length > 0)) {
                        const timingScore = delayFit && datasets[0].data.length > 0 ? 
                            calculateScore(delayFit, datasets[0].data) : null;
                        const velocityScore = velocityFit && datasets[1].data.length > 0 ? 
                            calculateScore(velocityFit, datasets[1].data) : null;
                        
                        // Build score text
                        let scoreText = '';
                        if (timingScore !== null) scoreText += `Timing: ${timingScore.toFixed(1)}%`;
                        if (timingScore !== null && velocityScore !== null) scoreText += '\n';
                        if (velocityScore !== null) scoreText += `Pressure: ${velocityScore.toFixed(1)}%`;

                        // Position at center of chart area
                        const centerX = chartAreaLeft + chartAreaWidth / 2;
                        const centerY = chartAreaTop + chartAreaHeight / 2;
                        
                        const scoreBox = document.createElement('div');
                        scoreBox.className = className;
                        scoreBox.style.cssText = `
                            position: absolute;
                            background: rgba(50,50,50,0.9);
                            color: white;
                            padding: 8px 12px;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: bold;
                            pointer-events: none;
                            z-index: 1000;
                            left: ${centerX}px;
                            top: ${centerY}px;
                            transform: translate(-50%, -50%);
                            text-align: center;
                            border: 2px solid rgba(255,255,255,0.3);
                            white-space: pre-line;
                        `;
                        scoreBox.textContent = scoreText;
                        document.body.appendChild(scoreBox);
                    }
                }, 50);
            }
        }
        
        function drawScatter() {
            // Calculate delays from Hand objects
            let dataRightDelay = [];
            let dataRightVelocity = [];
            let dataLeftDelay = [];
            let dataLeftVelocity = [];
            let maxDelayR = 500;
            let maxDelayL = 500;
            let lastTimeRight = null;
            let lastTimeLeft = null;
            
            // Calculate time offset (first note time)
            let startTime = 0;
            if (rightHand.times.length > 0 && leftHand.times.length > 0) {
                startTime = Math.min(rightHand.times[0], leftHand.times[0]);
            } else if (rightHand.times.length > 0) {
                startTime = rightHand.times[0];
            } else if (leftHand.times.length > 0) {
                startTime = leftHand.times[0];
            }
            
            // Process right hand data
            for (let i = 0; i < rightHand.notes.length; i++) {
                let time = rightHand.times[i];
                let midiNote = rightHand.notes[i];
                let label = midiToNote(midiNote);
                let velocity = rightHand.velocities[i];
                
                if (lastTimeRight !== null) {
                    let delay = time - lastTimeRight;
                    dataRightDelay.push({x: time - startTime, y: delay, note: label});
                    if (delay > maxDelayR) maxDelayR = Math.ceil(delay / 500) * 500;
                }
                dataRightVelocity.push({x: time - startTime, y: velocity, note: label});
                lastTimeRight = time;
            }
            
            // Process left hand data
            for (let i = 0; i < leftHand.notes.length; i++) {
                let time = leftHand.times[i];
                let midiNote = leftHand.notes[i];
                let label = midiToNote(midiNote);
                let velocity = leftHand.velocities[i];
                
                if (lastTimeLeft !== null) {
                    let delay = time - lastTimeLeft;
                    dataLeftDelay.push({x: time - startTime, y: delay, note: label});
                    if (delay > maxDelayL) maxDelayL = Math.ceil(delay / 500) * 500;
                }
                dataLeftVelocity.push({x: time - startTime, y: velocity, note: label});
                lastTimeLeft = time;
            }
            
            // Calculate max time for chart scaling
            let maxTime = 10000;
            if (rightHand.times.length > 0 || leftHand.times.length > 0) {
                let allTimes = [...rightHand.times, ...leftHand.times];
                maxTime = Math.max(...allTimes) - startTime;
            }
            
            console.log('Right hand data points:', dataRightDelay.length, dataRightVelocity.length);
            console.log('Left hand data points:', dataLeftDelay.length, dataLeftVelocity.length);
            
            // Prepare datasets for right hand chart
            let rightDatasets = [{
                label: 'Right Hand Delay (ms)',
                data: dataRightDelay,
                backgroundColor: 'rgba(255,0,0,0.7)', // Red for timing
                yAxisID: 'y'
            }, {
                label: 'Right Hand Velocity',
                data: dataRightVelocity,
                backgroundColor: 'rgba(0,255,0,0.7)', // Green for velocity
                yAxisID: 'y1'
            }];
            
            // Prepare datasets for left hand chart
            let leftDatasets = [{
                label: 'Left Hand Delay (ms)',
                data: dataLeftDelay,
                backgroundColor: 'rgba(255,0,0,0.7)', // Red for timing
                yAxisID: 'y'
            }, {
                label: 'Left Hand Velocity',
                data: dataLeftVelocity,
                backgroundColor: 'rgba(0,255,0,0.7)', // Green for velocity
                yAxisID: 'y1'
            }];
            
            // Create both charts using the common function
            createChart('scatter', 'right', rightDatasets, maxDelayR, maxTime, window.chartFits);
            createChart('scatterLeft', 'left', leftDatasets, maxDelayL, maxTime, window.chartFits);
        }
        drawScatter();
    </script>
</body>
</html>
